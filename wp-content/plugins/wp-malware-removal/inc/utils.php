<?php

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

class sfCanonicalUrl {

	function __construct( $url ) {
		$this->url = $this->normalizeURL( $url );
	}

	public function __toString() {
		return $this->url;
	}

	function normalizeURL( $url ) {

		$url = $this->get_array_first( explode( '#', $url ) ); // Strip fragment
		$url = trim( $url ); // Trim space
		$url = preg_replace( '/[\t\n\r]/', '', $url ); // Remove tabs, CR, LF

		$url = $this->fixEscapes( $url );
		if ( $url === false ) {
			return false; }

		// Extract the scheme
		$scheme = 'http';
		if ( preg_match( '~^([a-z]+[a-z0-9+\.\-]*)://(.*)$~i', $url, $matches ) ) {
			$scheme = strtolower( $matches[1] );
			$url    = $matches[2];
		}

		$query = '';
		if ( preg_match( '/^([^?]+)(\??.*)/', $url, $matches ) ) {      // capture URL and query string

			$url   = $matches[1];
			$query = $matches[2];
		}
		$endsWithSlash = substr( $url, -1 ) == '/';

		$path = '';
		preg_match( '~^(.*?)(?:(/.*)|$)~', $url, $matches ); // capture host and path
		$host = $matches[1];
		if ( isset( $matches[2] ) ) {
			$path = $matches[2];
		}

		$host = $this->fixHost( $host );
		if ( $host === false ) {
			return false; }

		// Prune path
		$path = preg_replace( '~//+~', '/', $path ); // Multiple slashes -> single slash
		$path = preg_replace( '~(?:^|/)\.(?:$|/)~', '/', $path ); // . path components removed
		while ( preg_match( '~/(?!\.\./)[^/]+/\.\.(?:$|/)~', $path ) ) { // Resolve ..
			$path = preg_replace( '~/(?!\.\./)[^/]+/\.\.(?:$|/)~', '/', $path, 1 );
		}
		$path = preg_replace( '~(?:^|/)\.\.(?:$|/)~', '/', $path ); // Eliminate .. at the beginning
		$path = trim( $path, '.' );
		$path = preg_replace( '/\.\.+/', '.', $path );

		if ( $path == '.' || $path == '' ) {
			$path = '/';
		} elseif ( $endsWithSlash && substr( $path, -1 ) != '/' ) {
			$path .= '/';
		}

		return $scheme . '://' . $host . $path . $query;
	}

	function get_array_first( $array ) {
		if ( empty( $array ) ) {
			return null;
		}

		return $array[0];
	}

	function fixEscapes( $url ) {
		$maxDepth = 1024;
		$i        = 0;
		while ( preg_match( '/%([0-9a-f]{2})/i', $url ) ) {
			$url = preg_replace_callback( '/%([0-9a-f]{2})/i', array( $this, 'hexToBinary' ), $url );
			$i++;

			if ( $i > $maxDepth ) {
				return false;
			}
		}

		return preg_replace_callback( '/[\x00-\x20\x7f-\xff#%]/', array( $this, 'binaryToHex' ), $url );
	}

	function hexToBinary( $matches ) {
		return hex2bin( $matches[1] );
	}

	function binaryToHex( $matches ) {
		 return '%' . bin2hex( $matches[0] );
	}

	function fixHost( $host ) {
		$host = $this->get_array_last( explode( '@', $host ) );         // Remove username:password

		if ( substr( $host, 0, 1 ) == '[' ) { // Literal IPv6
			if ( strpos( $host, ']' ) === false ) { // No closing bracket
				return false;
			}
		}

		$host = preg_replace( '/:\d+$/', '', $host ); // Remove port

		$u = rawurldecode( $host ); // Convert Unicode to IDNA

		if ( preg_match( '/[\x81-\xff]/', $u ) ) {
			if ( function_exists( 'idn_to_ascii' ) ) { // Convert domain name to IDNA ASCII form. Some PHP versions don't have this
				$host = idn_to_ascii( $u, IDNA_DEFAULT, INTL_IDNA_VARIANT_UTS46 );
			} else {
				trigger_error( 'PHP Intl extension is missing or use https://developer.wordpress.org/reference/classes/requests_idnaencoder/punycode_encode/', E_USER_NOTICE );
			}
		}

		$host = trim( $host, '.' ); // Eliminate extra dots
		$host = preg_replace( '/\.\.+/', '.', $host );

		if ( $iphost = $this->getIP( $host ) ) { // Normalize IP addresses
			return $iphost;
		}

		// $host = preg_replace( '/\\\\x([a-f0-9]+)/i', '%$1', $host );

		return strtolower( $host );
	}

	function get_array_last( $array ) {
		if ( empty( $array ) ) {
			return null;
		}

		return $array[ count( $array ) - 1 ];
	}

	function getIP( $host ) {

		if ( strlen( $host ) <= 15 ) {
			$host = $this->get_array_first( explode( ' ', $host ) );
		}

		if ( ! preg_match( '/^((?:0x[0-9a-f]+|[0-9\.])+)$/i', $host ) ) {
			return false;
		}

		$parts = explode( '.', $host );
		if ( count( $parts ) > 4 ) {
			return false;
		}

		$strings = array();
		foreach ( $parts as $i => $p ) {
			if ( $i == count( $parts ) - 1 ) {
				$strings[] = $this->normalizeNumber( $p, 5 - count( $parts ) );
			} else {
				$strings[] = $this->normalizeNumber( $p, 1 );
			}

			if ( $strings[ $i ] == '' ) {
				return '';
			}
		}

		return implode( '.', $strings );
	}

	function normalizeNumber( $part, $n ) {
		if ( $n <= 0 || $n > 4 ) {
			return '';
		}

		if ( preg_match( '/^0x(\d+)$/i', $part, $matches ) ) { // hexadecimal
			$part = hexdec( $matches[1] );
		} elseif ( preg_match( '/^0(\d+)$/i', $part, $matches ) ) { // octal
			$part = octdec( $matches[1] );
		} else {
			$part = (int) $part;
		}

		$strings = array_fill( 0, $n, '' );
		for ( $i = $n - 1; $i >= 0; $i-- ) {
			$strings[ $i ] = (string) ( $part & 0xff );
			$part          = $part >> 8;
		}
		return implode( '.', $strings );
	}
}
